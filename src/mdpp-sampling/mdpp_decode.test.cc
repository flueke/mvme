#include <gtest/gtest.h>

#include "mdpp-sampling/mdpp_decode.h"

using namespace mesytec::mvme;

// Taken from a real MDPP16 SCP module during a pulser run.
/*
0x400d00c1, 0x100a1602, 0x10da1000, 0x3fe2ff8b, 0x3fe3bf8b, 0x3011bf8d, 0x30578046, 0x3041c160,
0x3045c106, 0x30468117, 0x3045011a, 0x3044c115, 0x30450112, 0x1000157d, 0x10d01042, 0x30024009,
0x30040007, 0x3011801d, 0x305e4195, 0x306801a6, 0x3064018f, 0x30628189, 0x3063818f, 0x3062c18c,
0x3063018b, 0x100c15eb, 0x10dc0ff1, 0x3ffdbffc, 0x3fff3ff5, 0x302bfff6, 0x307040ad, 0x305c41ce,
0x3060c16e, 0x30610183, 0x305f4184, 0x30604180, 0x305f417e, 0x100215a3, 0x10d21031, 0x3feabfaa,
0x3febffa8, 0x3ff8bfc5, 0x30480136, 0x304fc142, 0x304cc132, 0x304c4131, 0x304d4135, 0x304c0131,
0x304bc130, 0x100815d8, 0x10981007, 0x3ff93fe4, 0x3ff8ffe3, 0x30024007, 0x305bc172, 0x305d4175,
0x305c4171, 0x30594165, 0x305ac16b, 0x305ac167, 0x305a0169, 0x100416cc, 0x1014103c, 0x3ffa3fe8,
0x3ffbffe6, 0x3009c002, 0x305a0182, 0x3065819c, 0x30610183, 0x3060c183, 0x3060c184, 0x30608182,
0x3060017f, 0x100b1547, 0x10db102a, 0x30054015, 0x3005c013, 0x3010402a, 0x305fc191, 0x3068c1a6,
0x3065c197, 0x3064018f, 0x3065c198, 0x30648192, 0x30644191, 0x10061558, 0x10961041, 0x300a0028,
0x300b8026, 0x3018803c, 0x3062c1a4, 0x306e41bf, 0x306a41a7, 0x306941a4, 0x306a81ab, 0x306a41aa,
0x306981a5, 0x100d16a3, 0x105d1046, 0x3feaffaa, 0x3fecbfa9, 0x3ffa7fbb, 0x3049c145, 0x3055815c,
0x3051c146, 0x30510143, 0x30524149, 0x30510146, 0x3050c143, 0x1001157f, 0x10111044, 0x3ff8bfe2,
0x3ffabfe2, 0x3006fff2, 0x30504159, 0x305f8187, 0x305a0166, 0x30588160, 0x305ac16d, 0x3059c167,
0x30598163, 0x100e1577, 0x101e1024, 0x3ff07fc1, 0x3ff0ffbf, 0x3ffbbfdb, 0x304e414a, 0x3053c151,
0x30520147, 0x30504140, 0x30518146, 0x30514143, 0x30508142, 0x100316b6, 0x10931061, 0x3ffffffe,
0x3002ffff, 0x3013400b, 0x305c4191, 0x306b81bb, 0x3067419a, 0x3066c19a, 0x3067419f, 0x3067419b,
0x30668199, 0x1009156b, 0x10d9104a, 0x3002800a, 0x30044008, 0x3011c019, 0x305bc18b, 0x306881aa,
0x3064018e, 0x3063418b, 0x30644193, 0x3063c18a, 0x3062418c, 0x1005157b, 0x10551087, 0x3ff27fc7,
0x3ff63fc7, 0x300abfd0, 0x3048c13e, 0x305a017e, 0x3054c14e, 0x30544150, 0x30550157, 0x3054c151,
0x30540150, 0x100f15ac, 0x105f1057, 0x3fedbfb5, 0x3fefffb4, 0x3fffbfc8, 0x3046c13a, 0x30530154,
0x3050413f, 0x304f813d, 0x30500141, 0x304fc13d, 0x304e813b, 0x1007157c, 0x1017106e, 0x3004c012,
0x30080014, 0x3018401c, 0x3059c181, 0x306c81c4, 0x30664194, 0x30664199, 0x3066c19d, 0x30668196,
0x30658195, 0xde2466cc
*/

TEST(MdppSamplingDecode, decode_mdpp16_basic)
{
    // 0x400d00c1 module_header, module_id=0x0d, module_setting=0x0, data_length=193 words
    // 0x100a1602 data_word, channel_address=10, mdpp_flags=0x0
    // 0x10da1000 data_word, channel_address=26, mdpp_flags=0x30
    // 0x3fe2ff8b
    // 0x3fe3bf8b
    // 0x3011bf8d
    // 0x30578046
    // 0x3041c160
    // 0x3045c106
    // 0x30468117
    // 0x3045011a
    // 0x3044c115
    // 0x30450112
    // 0x1000157d data_word, channel_address= 0, mdpp_flags=0x0
    // 0x10d01042 data_word, channel_address=16, mdpp_flags=0x30
    // 0x30024009
    // 0x30040007
    // 0x3011801d
    // 0x305e4195
    // 0x306801a6
    // 0x3064018f
    // 0x30628189
    // 0x3063818f
    // 0x3062c18c
    // 0x3063018b

    const std::vector<u32> data =
    {
        0x400d0018, 0x100a1602, 0x10da1000, 0x3fe2ff8b, 0x3fe3bf8b, 0x3011bf8d, 0x30578046, 0x3041c160,
        0x3045c106, 0x30468117, 0x3045011a, 0x3044c115, 0x30450112, 0x1000157d, 0x10d01042, 0x30024009,
        0x30040007, 0x3011801d, 0x305e4195, 0x306801a6, 0x3064018f, 0x30628189, 0x3063818f, 0x3062c18c,
        0x3063018b
    };

    auto decoded = mdpp_sampling::decode_mdpp16_scp_samples(data.data(), data.size());

    ASSERT_EQ(decoded.header, 0x400d0018);
    ASSERT_EQ(decoded.traces.size(), 2);
    ASSERT_EQ(decoded.traces[0].samples.size(), 20);
    ASSERT_EQ(decoded.traces[1].samples.size(), 20);
    ASSERT_EQ(decoded.traces[0].channel, 10);
    ASSERT_EQ(decoded.traces[1].channel, 0);
}

TEST(MdppSamplingDecode, decode_mdpp16_multihit_adjacent)
{
    // The second hit for channel 10 comes directly after the first.
    // The decoder currently appends the samples from the second event to the
    // trace of the first event.
    // If there was data from another channel in-between the first and second
    // hits, the decoder would instead create an additional trace for the second
    // hit.

    // 0x400d00c1 module_header, module_id=0x0d, module_setting=0x0, data_length=193 words
    // 0x100a1602 data_word, channel_address=10, mdpp_flags=0x0
    // 0x10da1000 data_word, channel_address=26, mdpp_flags=0x30
    // 0x3fe2ff8b
    // 0x3fe3bf8b
    // 0x3011bf8d
    // 0x30578046
    // 0x3041c160
    // 0x3045c106
    // 0x30468117
    // 0x3045011a
    // 0x3044c115
    // 0x30450112
    // 0x100a1602 data_word, channel_address=10, mdpp_flags=0x0
    // 0x10da1000 data_word, channel_address=26, mdpp_flags=0x30
    // 0x30024009
    // 0x30040007
    // 0x3011801d
    // 0x305e4195
    // 0x306801a6
    // 0x3064018f
    // 0x30628189
    // 0x3063818f
    // 0x3062c18c
    // 0x3063018b

    const std::vector<u32> data =
    {
        0x400d0018, 0x100a1602, 0x10da1000, 0x3fe2ff8b, 0x3fe3bf8b, 0x3011bf8d, 0x30578046, 0x3041c160,
        0x3045c106, 0x30468117, 0x3045011a, 0x3044c115, 0x30450112, 0x100a1602, 0x10da1000, 0x30024009,
        0x30040007, 0x3011801d, 0x305e4195, 0x306801a6, 0x3064018f, 0x30628189, 0x3063818f, 0x3062c18c,
        0x3063018b
    };

    auto decoded = mdpp_sampling::decode_mdpp16_scp_samples(data.data(), data.size());

    ASSERT_EQ(decoded.header, 0x400d0018);
    ASSERT_EQ(decoded.traces.size(), 1);
    ASSERT_EQ(decoded.traces[0].samples.size(), 40);
    ASSERT_EQ(decoded.traces[0].channel, 10);
}
