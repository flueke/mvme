# Step Expression
# ==============================================================================
# This script is the main part of the expression operator. It is executed each
# time data is available to consume.
#
# The script has access to all defined input and output arrays. For data access
# the plain variable name is used, e.g. 'input1' or 'output0'. Other properties
# are accessible in the same way as in the "Output Definition Script":
#
#   var_name.unit, var_name.size, var_name.lower_limits, var_name.upper_limits
#
# Parameter values and validity
# ------------------------------------------------------------------------------
# As described in the mvme manual Analysis Parameter Arrays can carry invalid
# values. An invalid value is not uncommon and will be generated by the
# analysis data extractors if no match is found for a certain array index. This
# happens if for example not all channels of an ADC module respond.
#
# Inside the analysis system invalid values are encoded as (quiet) NaNs with a
# special payload bit set to distinguish them from NaNs generated by arithmetic
# operations or through other means.
#
# A consequence of this is that the following code to sum up the values of an
# array will yield a NaN in case any of the array members are invalid:
#
#   var sum:=0; for (var i:=0; i<array[]; i+=1) { sum += array[i]; }
#
# To detect and generate invalid parameters the following functions have been
# defined for use inside scripts:
#
# is_valid(), is_invalid(), is_nan() and make_invalid()
#
# The first three test a single scalar value. make_invalid() is used to
# explicitly create an invalid parameter.
# A corrected version of the above loop:
#
#   var sum:=0; for (var i:=0; i<array[]; i+=1) {
#      sum += is_valid(array[i]) ? array[i] : 0.0;
#   }
#
#
# Basic "passthrough" examples
# ------------------------------------------------------------------------------
# The line below simply copies input0 to output0 (assignment of arrays performs
# the copy internally).
# output0 := input0;

# Doing the same manually using a loop:
# for (var i := 0; i < input0.size; i += 1)
# {
#     output0[i] := input0[i];
# }


output0 := input0;
