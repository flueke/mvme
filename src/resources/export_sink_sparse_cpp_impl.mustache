/* This file was auto generated by mvme-{{mvme_version}} on {{export_date}},
 * with data from run {{run_identifier}}.
 *
 * DO NOT MODFIY as this file will be overwritten when the export is run again!
 */

#include "{{export_header_file}}"
#include <limits>

using SparseArray = {{struct_name}}::SparseArray;

{{#array_info}}
const double {{struct_name}}::Limits::{{variable_name}}[{{dimension}}][2] =
{
{{#limits}}
    { {{lower_limit}}, {{upper_limit}} },
{{/limits}}
};
{{/array_info}}

const uint16_t {{struct_name}}::ArrayDimensions[] =
{
{{#array_info}}
    {{dimension}},
{{/array_info}}
};

const std::string {{struct_name}}::ArrayNames[] =
{
{{#array_info}}
    { "{{analysis_name}}" },
{{/array_info}}
};

const std::string {{struct_name}}::UnitLabels[] =
{
{{#array_info}}
    { "{{unit}}" },
{{/array_info}}
};

size_t {{struct_name}}::getArrayCount() const
{
    return {{struct_name}}::ArrayCount;
}

SparseArray *{{struct_name}}::getArray(size_t index)
{
    switch (index)
    {
{{#array_info}}
        case {{index}}: return &{{variable_name}};
{{/array_info}}
    };

    return nullptr;
}

const SparseArray *{{struct_name}}::getArray(size_t index) const
{
    return const_cast<{{struct_name}} *>(this)->getArray(index);
}

double {{struct_name}}::getValue(size_t arrayIndex, size_t paramIndex)
{
    if (arrayIndex < getArrayCount() && paramIndex < getArrayDimension(arrayIndex))
    {
        return (*getArray(arrayIndex))[paramIndex];
    }

    return std::numeric_limits<double>::quiet_NaN();
}

size_t {{struct_name}}::getArrayDimension(size_t index) const
{
    if (index < {{struct_name}}::ArrayCount)
    {
        return {{struct_name}}::ArrayDimensions[index];
    }

    return 0;
}

std::string {{struct_name}}::getArrayName(size_t index) const
{
    if (index < {{struct_name}}::ArrayCount)
    {
        return {{struct_name}}::ArrayNames[index];
    }
    return {};
}

std::string {{struct_name}}::getUnitLabel(size_t index) const
{
    if (index < {{struct_name}}::ArrayCount)
    {
        return {{struct_name}}::UnitLabels[index];
    }

    return {};
}

std::pair<double, double> {{struct_name}}::getLimits(size_t arrayIndex, size_t paramIndex) const
{
    if (paramIndex < getArrayDimension(arrayIndex))
    {
        switch (arrayIndex)
        {
{{#array_info}}
            case {{index}}:
                return std::make_pair(
                    {{struct_name}}::Limits::{{variable_name}}[paramIndex][0],
                    {{struct_name}}::Limits::{{variable_name}}[paramIndex][1]);
{{/array_info}}
        }
    }

    return std::make_pair(
        std::numeric_limits<double>::quiet_NaN(),
        std::numeric_limits<double>::quiet_NaN());
}

static std::istream &read(std::istream &in, SparseArray &dest)
{
    uint16_t size = 0;

    in.read(reinterpret_cast<char *>(&size), sizeof(size));

    if (!in.good())
        size = 0;

    dest.indexes.resize(size);
    dest.values.resize(size);

    if (size > 0)
    {
        in.read(reinterpret_cast<char *>(dest.indexes.data()), size * sizeof(uint16_t));
        in.read(reinterpret_cast<char *>(dest.values.data()),  size * sizeof(double));
    }

    return in;
}

std::istream &read(std::istream &in, {{struct_name}} &event)
{
    for (size_t arrayIndex = 0;
         arrayIndex < event.getArrayCount();
         arrayIndex++)
    {
        SparseArray *destArray = event.getArray(arrayIndex);
        assert(destArray);
        read(in, *destArray);
    }

    return in;
}

{{!
vim:ft=cpp
}}
