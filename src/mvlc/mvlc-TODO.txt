* USB/ETH low level read cleanup
* USB2 loses data under windows.

* Revisit MVLCDialog::stackTransaction(const QVector<u32> &stack, QVector<u32> &dest)
  Is this correct in case the Continue bit is set?

* refactor UDP to ETH. It's a better name for what the system actually is and it's easier
  to distinguish between USB/ETH than USB/UDP.

* Add stat for packets that have leftoverBytes (packetLen % 4 != 0).

* Vary USB readout buffer sizes and check for data loss. Try multiples of 1024
  (the max USB3 packet size) and non-multiples of 1024. Do verify if all data
  arrives. Wireshark does show packets sizes of 400k bytes, possibly more...
  -> No data loss so far. Despite a read size of 1536 bytes.

* Make a std::error_category for getaddrinfo (enum, category, make_error_code).
  It's needed for good winsock error reporting.

* Add NoIAck option to VMEConfig and use it in the MVLC setup code

* Polling udp::Impl stats (getLossCounters(), getPacketSizeCounters()) from the GUI is
  currently not taking the higher-level locks. This means the readout thread or a thread
  doing periodic polling can update those values concurrently to the GUI reading them.
  Either implement low level locks in the UDP code or use the higher level ones which
  currently are in MVLCObject.

* The usb::Impl::read() on Windows and the udp::Impl::read() calls on both systems can take
  longer than the user specified timeout as they are issuing multiple read/receive calls
  internally, each using the previously set timeout value. Document this behaviour and/or
  work around it by taking into account how much time has elapsed between each of the
  individual read/receive calls.

* Build a tool to verify incoming readout data. Check headers and pointers. Test this with
  different incoming event sizes.
  For the first pass it's ok to do this offline.

* Low Level MVLC Ethernet Debugging:

    ifconfig enp2s0 192.168.42.1 netmask 255.255.255.0 up
    arp -i enp2s0 -s 192.168.42.2 ab:cd:12:34:56:78

  Start wireshark or tcpdump in a second terminal window
    sudo tcpdump -i enp2s0 -vvXX

  Use netcat to generate an UDP packet containing "Hello, World!" as the payload.
    echo "Hello, world!" | netcat -u 192.168.42.2 9000

  To delete the arp entry:
    arp -i enp2s0 -d 192.168.42.g

-----------------------------------------------------------------------------------------

USB readout
-----------
* Read multiples of 1024 bytes (the USB3 max bulk transfer packet size)
* USB2: wMaxPacketSize is 512 for the bulk endpoints
* USB3: wMaxPacketSize is 1024 for the bulkd endpoints

* To maximize USB2 throughput both the read request size and the read timeout matter.
  Buffers sizes starting from 500k to 1MB seem to be ok. At 45MB/s reading a 1MB/s buffer
  will take 22 ms, so the timeout should be longer than that.
  If the timeout is too short readout rate will drop dramatically from 45MB/s down to 32
  MB/s with short timeouts.

  Very long timeouts will currently stall the GUI but this is just a matter of not doing
  I/O in the GUI thread. Instead things like QtConcurrent::run should be used to do the
  operation that requires a MVLC lock on a separate thread.

* A single call to FT_ReadPipeEx is limited to a size of 1MB under both operating systems
  and with both USB2 and 3.

